// Mock dependencies first before requiring anything
const mockWebSocketInstance = {
  on: jest.fn(),
  send: jest.fn(),
  close: jest.fn(),
  readyState: 1
};

const MockWebSocket = jest.fn(() => mockWebSocketInstance);
MockWebSocket.OPEN = 1;
MockWebSocket.CLOSED = 3;

jest.mock('ws', () => MockWebSocket);

jest.mock('../http.js', () => ({
  UA: 'test-user-agent'
}));

jest.mock('../myCooke.js', () => ({
  CookeObj: {
    Cookie: 'test-cookie'
  }
}));

jest.mock('../pub-sub.js', () => ({
  Event: {
    $emit: jest.fn()
  }
}));

// Mock index.js verifyCookie function
jest.mock('../index.js', () => ({
  verifyCookie: jest.fn(() => Promise.resolve({ success: true }))
}), { virtual: true });

describe('websocket.js - WebSocketè¿žæŽ¥ç®¡ç†æµ‹è¯•', () => {
  let websocket;
  let Event;
  let indexModule;

  beforeEach(() => {
    jest.clearAllMocks();

    // Reset mock instance
    mockWebSocketInstance.on.mockClear();
    mockWebSocketInstance.send.mockClear();
    mockWebSocketInstance.close.mockClear();

    // é‡æ–°åŠ è½½æ¨¡å—
    Event = require('../pub-sub.js').Event;
    indexModule = require('../index.js');
    websocket = require('../websocket.js');

    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('æ¨¡å—å¯¼å‡ºéªŒè¯', () => {
    test('åº”è¯¥å¯¼å‡ºcreateSocketå‡½æ•°', () => {
      expect(websocket).toHaveProperty('createSocket');
      expect(typeof websocket.createSocket).toBe('function');
    });
  });

  describe('WebSocketè¿žæŽ¥åˆ›å»º', () => {
    test('åº”è¯¥ä½¿ç”¨æ­£ç¡®çš„URLå’Œheadersåˆ›å»ºWebSocketè¿žæŽ¥', () => {
      websocket.createSocket();

      expect(MockWebSocket).toHaveBeenCalledWith(
        'ws://wechat.v2.traceint.com/ws?ns=prereserve/queue',
        expect.objectContaining({
          headers: expect.objectContaining({
            'User-Agent': 'test-user-agent',
            'App-Version': '2.0.14',
            Cookie: 'test-cookie',
            Connection: 'Upgrade',
            Upgrade: 'websocket',
            'Sec-WebSocket-Version': 13
          })
        })
      );
    });

    test('åº”è¯¥åŒ…å«æœ‰æ•ˆçš„Sec-WebSocket-Key', () => {
      websocket.createSocket();

      const callArgs = MockWebSocket.mock.calls[0][1];
      expect(callArgs.headers['Sec-WebSocket-Key']).toBeDefined();
      expect(typeof callArgs.headers['Sec-WebSocket-Key']).toBe('string');
      expect(callArgs.headers['Sec-WebSocket-Key'].length).toBeGreaterThan(0);
    });

    test('åº”è¯¥æ³¨å†Œæ‰€æœ‰å¿…è¦çš„äº‹ä»¶ç›‘å¬å™¨', () => {
      websocket.createSocket();

      expect(mockWebSocketInstance.on).toHaveBeenCalledWith('open', expect.any(Function));
      expect(mockWebSocketInstance.on).toHaveBeenCalledWith('message', expect.any(Function));
      expect(mockWebSocketInstance.on).toHaveBeenCalledWith('close', expect.any(Function));
    });

    test('åº”è¯¥è¿”å›žWebSocketå®žä¾‹', () => {
      const socket = websocket.createSocket();
      expect(socket).toBe(mockWebSocketInstance);
    });
  });

  describe('WebSocketè¿žæŽ¥æ‰“å¼€äº‹ä»¶', () => {
    test('åº”è¯¥åœ¨è¿žæŽ¥æ‰“å¼€æ—¶å‘é€åˆå§‹æ¶ˆæ¯', () => {
      websocket.createSocket();

      const openHandler = mockWebSocketInstance.on.mock.calls.find(
        call => call[0] === 'open'
      )[1];

      openHandler();

      expect(mockWebSocketInstance.send).toHaveBeenCalledWith(
        JSON.stringify({ ns: 'prereserve/queue', msg: '' })
      );
    });

    test('åº”è¯¥å¯åŠ¨100mså¿ƒè·³é—´éš”', () => {
      websocket.createSocket();

      const openHandler = mockWebSocketInstance.on.mock.calls.find(
        call => call[0] === 'open'
      )[1];

      openHandler();

      // åˆå§‹å‘é€
      expect(mockWebSocketInstance.send).toHaveBeenCalledTimes(1);

      // 100msåŽåº”è¯¥å†æ¬¡å‘é€
      jest.advanceTimersByTime(100);
      expect(mockWebSocketInstance.send).toHaveBeenCalledTimes(2);

      // å†100ms
      jest.advanceTimersByTime(100);
      expect(mockWebSocketInstance.send).toHaveBeenCalledTimes(3);

      // 1ç§’åº”è¯¥å‘é€çº¦10æ¬¡
      jest.advanceTimersByTime(700);
      expect(mockWebSocketInstance.send.mock.calls.length).toBeGreaterThanOrEqual(10);
    });
  });

  describe('WebSocketæ¶ˆæ¯å¤„ç†', () => {
    let messageHandler;

    beforeEach(() => {
      websocket.createSocket();
      messageHandler = mockWebSocketInstance.on.mock.calls.find(
        call => call[0] === 'message'
      )[1];
    });

    test('åº”è¯¥æ­£ç¡®è§£æžJSONæ¶ˆæ¯', () => {
      const mockMessage = JSON.stringify({
        ns: 'test',
        msg: 'æµ‹è¯•æ¶ˆæ¯',
        code: 0,
        data: 1
      });

      expect(() => {
        messageHandler(Buffer.from(mockMessage));
      }).not.toThrow();
    });

    test('åº”è¯¥åœ¨ç¬¬ä¸€æ¬¡æ¡æ‰‹æˆåŠŸæ—¶è°ƒç”¨verifyCookie', async () => {
      const mockMessage = JSON.stringify({
        ns: 'prereserve/queue',
        msg: 'æ¡æ‰‹æˆåŠŸ',
        code: 0,
        data: 1
      });

      messageHandler(Buffer.from(mockMessage));

      // ç­‰å¾…Promise
      await new Promise(resolve => setImmediate(resolve));

      expect(indexModule.verifyCookie).toHaveBeenCalled();
    });

    test('åº”è¯¥åœ¨èŽ·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥æ—¶è§¦å‘resetWsäº‹ä»¶', () => {
      const mockMessage = JSON.stringify({
        ns: 'prereserve/queue',
        msg: 'èŽ·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥ï¼Œè¯·å°è¯•é‡æ–°è¿›å…¥æ­¤é¡µé¢',
        code: -1,
        data: null
      });

      messageHandler(Buffer.from(mockMessage));

      expect(Event.$emit).toHaveBeenCalledWith('resetWs');
    });

    test('åº”è¯¥åœ¨Cookieæ— æ•ˆæ—¶è§¦å‘InvalidCookieäº‹ä»¶', () => {
      const mockMessage = JSON.stringify({
        ns: 'prereserve/queue',
        msg: 1000,
        code: -1,
        data: null
      });

      messageHandler(Buffer.from(mockMessage));

      expect(Event.$emit).toHaveBeenCalledWith('InvalidCookie');
    });

    test('åº”è¯¥åœ¨é¢„çº¦æˆåŠŸæ—¶è§¦å‘successäº‹ä»¶', () => {
      const mockMessage = JSON.stringify({
        ns: 'prereserve/queue',
        msg: 'ä½ å·²ç»æˆåŠŸç™»è®°äº†æ˜Žå¤©çš„,åº§ä½å·: 225',
        code: 0,
        data: 0
      });

      messageHandler(Buffer.from(mockMessage));

      expect(Event.$emit).toHaveBeenCalledWith('success');
    });

    test('åº”è¯¥è¯†åˆ«ä¸åœ¨é¢„çº¦æ—¶é—´çš„æ¶ˆæ¯', () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const mockMessage = JSON.stringify({
        ns: 'prereserve/queue',
        msg: 'ä¸åœ¨é¢„çº¦æ—¶é—´å†…,è¯·åœ¨ 20:00-23:59 æ¥é¢„çº¦',
        code: 0,
        data: 0
      });

      messageHandler(Buffer.from(mockMessage));

      expect(consoleSpy).toHaveBeenCalledWith('å½“å‰ä¸åœ¨æŽ’é˜Ÿæ—¶é—´');
      consoleSpy.mockRestore();
    });

    test('åº”è¯¥è¯†åˆ«æŽ’é˜ŸæˆåŠŸæ¶ˆæ¯', () => {
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      const mockMessage = JSON.stringify({
        ns: 'prereserve/queue',
        msg: 'æŽ’é˜ŸæˆåŠŸï¼è¯·åœ¨2åˆ†é’Ÿå†…é€‰æ‹©åº§ä½ï¼Œå¦åˆ™éœ€è¦é‡æ–°æŽ’é˜Ÿã€‚',
        code: 0,
        data: 0
      });

      messageHandler(Buffer.from(mockMessage));

      expect(consoleSpy).toHaveBeenCalledWith('ã€æç¤ºã€‘æ­£åœ¨è‡ªåŠ¨æŽ’é˜Ÿ..');
      consoleSpy.mockRestore();
    });
  });

  describe('WebSocketè¿žæŽ¥å…³é—­', () => {
    test('åº”è¯¥åœ¨å…³é—­æ—¶æ¸…é™¤å¿ƒè·³å®šæ—¶å™¨', () => {
      websocket.createSocket();

      // è§¦å‘openäº‹ä»¶å¯åŠ¨å¿ƒè·³
      const openHandler = mockWebSocketInstance.on.mock.calls.find(
        call => call[0] === 'open'
      )[1];
      openHandler();

      // éªŒè¯å¿ƒè·³æ­£åœ¨è¿è¡Œ
      jest.advanceTimersByTime(100);
      const sendCountBeforeClose = mockWebSocketInstance.send.mock.calls.length;

      // è§¦å‘closeäº‹ä»¶
      const closeHandler = mockWebSocketInstance.on.mock.calls.find(
        call => call[0] === 'close'
      )[1];
      closeHandler();

      // å†å‰è¿›æ—¶é—´ï¼Œå¿ƒè·³åº”è¯¥å·²åœæ­¢
      jest.advanceTimersByTime(1000);
      expect(mockWebSocketInstance.send.mock.calls.length).toBe(sendCountBeforeClose);
    });
  });

  describe('createSocketKeyå‡½æ•°', () => {
    test('åº”è¯¥ç”Ÿæˆä¸åŒçš„keyï¼ˆé€šè¿‡å¤šæ¬¡è°ƒç”¨ï¼‰', () => {
      websocket.createSocket();
      const key1 = MockWebSocket.mock.calls[0][1].headers['Sec-WebSocket-Key'];

      MockWebSocket.mockClear();

      websocket.createSocket();
      const key2 = MockWebSocket.mock.calls[0][1].headers['Sec-WebSocket-Key'];

      // ç”±äºŽæ˜¯éšæœºç”Ÿæˆçš„UUIDï¼Œä¸¤æ¬¡è°ƒç”¨åº”è¯¥ç”Ÿæˆä¸åŒçš„keyï¼ˆæžå¤§æ¦‚çŽ‡ï¼‰
      expect(key1).toBeDefined();
      expect(key2).toBeDefined();
    });

    test('ç”Ÿæˆçš„keyåº”è¯¥æ˜¯base64æ ¼å¼', () => {
      websocket.createSocket();

      const key = MockWebSocket.mock.calls[0][1].headers['Sec-WebSocket-Key'];
      // Base64æ ¼å¼éªŒè¯ï¼šåº”è¯¥åªåŒ…å«å­—æ¯ã€æ•°å­—ã€+ã€/å’Œ=
      expect(key).toMatch(/^[A-Za-z0-9+/=]+$/);
    });
  });

  describe('æ¶ˆæ¯æ ¼å¼éªŒè¯', () => {
    test('å‘é€çš„payloadåº”è¯¥æ˜¯æ­£ç¡®çš„JSONæ ¼å¼', () => {
      websocket.createSocket();

      const openHandler = mockWebSocketInstance.on.mock.calls.find(
        call => call[0] === 'open'
      )[1];
      openHandler();

      const sentPayload = mockWebSocketInstance.send.mock.calls[0][0];
      const parsed = JSON.parse(sentPayload);

      expect(parsed).toEqual({
        ns: 'prereserve/queue',
        msg: ''
      });
    });
  });

  describe('è¾¹ç•Œæƒ…å†µå¤„ç†', () => {
    test('åº”è¯¥å¤„ç†ç©ºæ¶ˆæ¯', () => {
      websocket.createSocket();

      const messageHandler = mockWebSocketInstance.on.mock.calls.find(
        call => call[0] === 'message'
      )[1];

      expect(() => {
        messageHandler(Buffer.from(JSON.stringify({ ns: '', msg: '', code: 0, data: 0 })));
      }).not.toThrow();
    });

    test('åº”è¯¥å¤„ç†æ¶ˆæ¯ä¸­çš„ç‰¹æ®Šå­—ç¬¦', () => {
      websocket.createSocket();

      const messageHandler = mockWebSocketInstance.on.mock.calls.find(
        call => call[0] === 'message'
      )[1];

      const specialMessage = JSON.stringify({
        ns: 'test',
        msg: 'ä½ å·²ç»æˆåŠŸç™»è®°äº†æ˜Žå¤©çš„,åº§ä½å·: 225 ðŸŽ‰',
        code: 0,
        data: 0
      });

      expect(() => {
        messageHandler(Buffer.from(specialMessage));
      }).not.toThrow();
    });
  });
});
